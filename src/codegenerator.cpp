#include "codegenerator.h"
#include <QRegularExpression>
#include <QFile>
#include <QTextStream>

CodeGenerator::CodeGenerator()
{
    initializeFunctionMacros();
}

QString CodeGenerator::generateCode(const ChipConfig& config)
{
    // 检查是否存在默认的 cvi_board_init.c 文件
    QString defaultFilePath = "C:\\Users\\jansonxie\\Desktop\\CviCubeMX\\boards\\cv184x\\cv1842hp_wevb_0014a_emmc\\u-boot\\cvi_board_init.c";
    QFile defaultFile(defaultFilePath);
    
    if (defaultFile.exists()) {
        // 如果存在默认文件，则更新它
        return updateExistingFile(defaultFilePath, config);
    } else {
        // 如果不存在默认文件，则生成新的代码（保留原有逻辑）
        QString code;
        
        // 生成文件头
        code += generateHeader();
        
        // 生成包含文件
        // code += "\n#include \"cvi_board_init.h\"\n";
        // code += "#include \"pinmux.h\"\n\n";
        
        // 生成引脚复用函数
        code += generatePinmuxFunction(config);
        
        return code;
    }
}

QString CodeGenerator::updateExistingFile(const QString& filePath, const ChipConfig& config)
{
    QFile file(filePath);
    if (!file.open(QIODevice::ReadOnly | QIODevice::Text)) {
        return QString("Error: Cannot open file %1").arg(filePath);
    }
    
    QTextStream in(&file);
    QString content = in.readAll();
    file.close();
    
    // 查找现有的生成配置块并删除（包括前后的空行）
    QRegularExpression generatedRegex("\\n*\\s*// Generated PINMUX configurations\\n.*?(?=\\n*\\s*return\\s+0\\s*;)", 
                                     QRegularExpression::DotMatchesEverythingOption);
    content.remove(generatedRegex);
    
    // 清理可能存在的多余换行符（在return之前）
    QRegularExpression multipleNewlines("(\\n\\s*){3,}(\\s*return\\s+0\\s*;)");
    content.replace(multipleNewlines, "\n\n\\2");
    
    // 查找 return 0; 的位置，但不依赖其当前的缩进状态
    QRegularExpression returnRegex("\\n*\\s*return\\s+0\\s*;");
    QRegularExpressionMatch match = returnRegex.match(content);
    
    if (!match.hasMatch()) {
        return "Error: Cannot find 'return 0;' in the existing file";
    }
    
    int returnPosition = match.capturedStart();
    
    // 生成新的 PINMUX 配置
    QString pinmuxConfig = generatePinmuxConfig(config);
    
    if (!pinmuxConfig.isEmpty()) {
        // 在 return 0; 之前插入新的配置
        QString newContent = content.left(returnPosition);
        
        // 确保以换行结尾
        if (!newContent.endsWith("\n")) {
            newContent += "\n";
        }
        
        // 始终使用制表符缩进，不依赖于当前return语句的缩进状态
        newContent += "\n\t// Generated PINMUX configurations\n";
        newContent += pinmuxConfig;
        newContent += "\n\treturn 0;\n";
        newContent += "}";
        
        // 写回文件
        if (!file.open(QIODevice::WriteOnly | QIODevice::Text)) {
            return QString("Error: Cannot write to file %1").arg(filePath);
        }
        
        QTextStream out(&file);
        out << newContent;
        file.close();
        
        return "File updated successfully";
    } else {
        // 如果没有配置要添加，确保删除任何现有的生成配置，并保持正确的return格式
        QRegularExpression returnFix("\\n*\\s*return\\s+0\\s*;");
        content.replace(returnFix, "\n\treturn 0;");
        
        if (!file.open(QIODevice::WriteOnly | QIODevice::Text)) {
            return QString("Error: Cannot write to file %1").arg(filePath);
        }
        
        QTextStream out(&file);
        out << content;
        file.close();
        
        return "Existing generated configurations removed";
    }
}

QString CodeGenerator::generateHeader()
{
    QString header;
    QDateTime currentTime = QDateTime::currentDateTime();
    
    header += "/**\n";
    header += " * @file cvi_board_init.c\n";
    header += " * @brief Board initialization file generated by CviCubeMX\n";
    header += " * @author CviCubeMX Tool\n";
    header += QString(" * @date %1\n").arg(currentTime.toString("yyyy-MM-dd hh:mm:ss"));
    header += " */\n\n";
    
    return header;
}

QString CodeGenerator::generatePinmuxFunction(const ChipConfig& config)
{
    QString function;
    
    function += "/**\n";
    function += " * @brief Initialize board pin multiplexing\n";
    function += QString(" * @note Generated for chip: %1\n").arg(config.getChipType());
    function += " */\n";
    function += "int cvi_board_init(void)\n";
    function += "{\n";
    
    // 添加芯片类型注释
    function += QString("    // Pin configuration for %1\n").arg(config.getChipType());
    function += "    // Package type: ";
    
    QString chipType = config.getChipType();
    bool isQFN = (chipType.endsWith('c') || chipType == "cv1842cp");
    bool isBGA = (chipType.endsWith('h') || chipType == "cv1842hp");
    
    if (isQFN) {
        function += "QFN (Quad Flat No-leads)\n";
    } else if (isBGA) {
        function += "BGA (Ball Grid Array)\n";
    } else {
        function += "Unknown\n";
    }
    function += "\n";
    
    // 生成引脚复用配置
    QMap<QString, QString> pinFunctions = config.getAllPinFunctions();
    
    // 按功能分组
    QMap<QString, QStringList> functionGroups;
    for (auto it = pinFunctions.begin(); it != pinFunctions.end(); ++it) {
        QString pinName = it.key();
        QString funcName = it.value();
        if (funcName != "GPIO") { // GPIO不需要特殊配置
            functionGroups[funcName].append(pinName);
        }
    }
    
    // 生成每个功能组的配置
    for (auto it = functionGroups.begin(); it != functionGroups.end(); ++it) {
        QString funcName = it.key();
        QStringList pins = it.value();
        
        function += QString("    // %1 pins configuration\n").arg(funcName);
        
        for (const QString& pinName : pins) {
            QString pinmuxMacro = getPinMuxName(pinName, funcName);
            function += QString("    PINMUX_CONFIG(%1, %2);\n").arg(pinName, pinmuxMacro);
        }
        function += "\n";
    }
    
    // 如果没有配置任何引脚，添加默认注释
    if (functionGroups.isEmpty()) {
        function += "    // No special pin functions configured\n";
        function += "    // All pins are set to GPIO by default\n";
    }
    
    function += "}\n";
    
    return function;
}

QString CodeGenerator::generatePinmuxConfig(const ChipConfig& config)
{
    QString configCode;
    
    // 生成引脚复用配置
    QMap<QString, QString> pinFunctions = config.getAllPinFunctions();
    
    // 按功能分组
    QMap<QString, QStringList> functionGroups;
    for (auto it = pinFunctions.begin(); it != pinFunctions.end(); ++it) {
        QString pinName = it.key();
        QString funcName = it.value();
        if (funcName != "GPIO") { // GPIO不需要特殊配置
            functionGroups[funcName].append(pinName);
        }
    }
    
    // 生成每个功能组的配置
    bool firstGroup = true;
    for (auto it = functionGroups.begin(); it != functionGroups.end(); ++it) {
        QString funcName = it.key();
        QStringList pins = it.value();
        
        if (!firstGroup) {
            configCode += "\n";
        }
        firstGroup = false;
        
        // 使用制表符缩进，与文件中其他行保持一致
        configCode += QString("\t// %1 pins configuration\n").arg(funcName);
        
        for (const QString& pinName : pins) {
            QString pinmuxMacro = getPinMuxName(pinName, funcName);
            configCode += QString("\tPINMUX_CONFIG(%1, %2);\n").arg(pinName, pinmuxMacro);
        }
    }
    
    return configCode;
}

QString CodeGenerator::getPinMuxName(const QString& pinName, const QString& function)
{
    // 使用新的引脚功能系统获取宏名称
    QString macroName = m_pinFunction.getFunctionMacroName(pinName, function);
    
    // 如果没有找到特定的宏名称，使用通用的处理方式
    if (macroName == function.toUpper()) {
        // 根据引脚名称和功能生成PINMUX宏名称
        QString basePinName = pinName;
        
        // 处理新的引脚命名方式
        if (basePinName.startsWith("PIN_")) {
            // 旧的PIN_数字格式
            int pinNumber = basePinName.mid(4).toInt();
            if (pinNumber <= 32) {
                basePinName = QString("GPIOA%1").arg(pinNumber - 1);
            } else {
                basePinName = QString("GPIOB%1").arg(pinNumber - 33);
            }
        } else if (basePinName.contains(QRegularExpression("^[A-R]\\d+$"))) {
            // BGA格式：A1, B2, 等
            QChar rowChar = basePinName[0];
            int colNumber = basePinName.mid(1).toInt();
            
            // 将BGA坐标转换为GPIO编号
            // 这里使用简化映射，实际项目中需要根据具体芯片规格书映射
            int rowIndex = rowChar.toLatin1() - 'A';
            if (rowChar >= 'J') rowIndex--; // 跳过I
            
            int gpioNumber = rowIndex * 15 + (colNumber - 1);
            
            if (gpioNumber < 64) {
                basePinName = QString("GPIOA%1").arg(gpioNumber);
            } else {
                basePinName = QString("GPIOB%1").arg(gpioNumber - 64);
            }
        } else if (basePinName.contains(QRegularExpression ("^\\d+$"))) {
            // QFN格式：纯数字
            int pinNumber = basePinName.toInt();
            if (pinNumber <= 32) {
                basePinName = QString("GPIOA%1").arg(pinNumber - 1);
            } else {
                basePinName = QString("GPIOB%1").arg(pinNumber - 33);
            }
        }
        
        // 如果是特定功能，直接返回功能宏名称
        if (function.contains("CAM_") || function.contains("AUX") || 
            function.contains("DBG_") || function.contains("XGPIO") ||
            function.contains("PAD_") || function.contains("VI") ||
            function.contains("VO") || function.contains("SD") ||
            function.contains("MIPI") || function.contains("PWM_") ||
            function.contains("IIC")) {
            return function;
        }
        
        // 生成通用功能宏名称
        QString functionMacro;
        if (function == "I2C") {
            // I2C功能需要区分SDA和SCL
            static int i2cIndex = 0;
            if (i2cIndex % 2 == 0) {
                functionMacro = QString("IIC%1_SDA").arg(i2cIndex / 2);
            } else {
                functionMacro = QString("IIC%1_SCL").arg(i2cIndex / 2);
            }
            i2cIndex++;
        } else if (function == "UART") {
            // UART功能需要区分TX和RX
            static int uartIndex = 0;
            if (uartIndex % 2 == 0) {
                functionMacro = QString("UART%1_TX").arg(uartIndex / 2);
            } else {
                functionMacro = QString("UART%1_RX").arg(uartIndex / 2);
            }
            uartIndex++;
        } else if (function == "SPI") {
            // SPI功能需要区分不同信号线
            static int spiIndex = 0;
            QStringList spiSignals = {"CLK", "MOSI", "MISO", "CS"};
            functionMacro = QString("SPI%1_%2").arg(spiIndex / 4).arg(spiSignals[spiIndex % 4]);
            spiIndex++;
        } else if (function == "ADC") {
            static int adcIndex = 0;
            functionMacro = QString("ADC%1").arg(adcIndex);
            adcIndex++;
        } else if (function == "PWM") {
            static int pwmIndex = 0;
            functionMacro = QString("PWM%1").arg(pwmIndex);
            pwmIndex++;
        } else if (function == "Timer") {
            static int timerIndex = 0;
            functionMacro = QString("TIMER%1").arg(timerIndex);
            timerIndex++;
        } else {
            functionMacro = function.toUpper();
        }
        
        return functionMacro;
    }
    
    return macroName;
}

void CodeGenerator::initializeFunctionMacros()
{
    m_functionMacros["GPIO"] = "GPIO";
    m_functionMacros["ADC"] = "ADC";
    m_functionMacros["I2C"] = "IIC";
    m_functionMacros["UART"] = "UART";
    m_functionMacros["SPI"] = "SPI";
    m_functionMacros["PWM"] = "PWM";
    m_functionMacros["Timer"] = "TIMER";
}
