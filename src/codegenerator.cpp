#include "codegenerator.h"
#include <QRegularExpression>

CodeGenerator::CodeGenerator()
{
    initializeFunctionMacros();
}

QString CodeGenerator::generateCode(const ChipConfig& config)
{
    QString code;
    
    // 生成文件头
    code += generateHeader();
    
    // 生成包含文件
    code += "\n#include \"cvi_board_init.h\"\n";
    code += "#include \"pinmux.h\"\n\n";
    
    // 生成引脚复用函数
    code += generatePinmuxFunction(config);
    
    // 生成文件尾
    code += generateFooter();
    
    return code;
}

QString CodeGenerator::generateHeader()
{
    QString header;
    QDateTime currentTime = QDateTime::currentDateTime();
    
    header += "/**\n";
    header += " * @file cvi_board_init.c\n";
    header += " * @brief Board initialization file generated by CviCubeMX\n";
    header += " * @author CviCubeMX Tool\n";
    header += QString(" * @date %1\n").arg(currentTime.toString("yyyy-MM-dd hh:mm:ss"));
    header += " */\n\n";
    
    return header;
}

QString CodeGenerator::generatePinmuxFunction(const ChipConfig& config)
{
    QString function;
    
    function += "/**\n";
    function += " * @brief Initialize board pin multiplexing\n";
    function += QString(" * @note Generated for chip: %1\n").arg(config.getChipType());
    function += " */\n";
    function += "void cvi_board_init(void)\n";
    function += "{\n";
    
    // 添加芯片类型注释
    function += QString("    // Pin configuration for %1\n").arg(config.getChipType());
    function += "    // Package type: ";
    
    QString chipType = config.getChipType();
    bool isQFN = (chipType.endsWith('c') || chipType == "cv1842cp");
    bool isBGA = (chipType.endsWith('h') || chipType == "cv1842hp");
    
    if (isQFN) {
        function += "QFN (Quad Flat No-leads)\n";
    } else if (isBGA) {
        function += "BGA (Ball Grid Array)\n";
    } else {
        function += "Unknown\n";
    }
    function += "\n";
    
    // 生成引脚复用配置
    QMap<QString, QString> pinFunctions = config.getAllPinFunctions();
    
    // 按功能分组
    QMap<QString, QStringList> functionGroups;
    for (auto it = pinFunctions.begin(); it != pinFunctions.end(); ++it) {
        QString pinName = it.key();
        QString funcName = it.value();
        if (funcName != "GPIO") { // GPIO不需要特殊配置
            functionGroups[funcName].append(pinName);
        }
    }
    
    // 生成每个功能组的配置
    for (auto it = functionGroups.begin(); it != functionGroups.end(); ++it) {
        QString funcName = it.key();
        QStringList pins = it.value();
        
        function += QString("    // %1 pins configuration\n").arg(funcName);
        
        for (const QString& pinName : pins) {
            QString pinmuxMacro = getPinMuxName(pinName, funcName);
            function += QString("    PINMUX(%1, %2);\n").arg(pinName, pinmuxMacro);
        }
        function += "\n";
    }
    
    // 如果没有配置任何引脚，添加默认注释
    if (functionGroups.isEmpty()) {
        function += "    // No special pin functions configured\n";
        function += "    // All pins are set to GPIO by default\n";
    }
    
    function += "}\n";
    
    return function;
}

QString CodeGenerator::generateFooter()
{
    QString footer;
    
    footer += "\n/**\n";
    footer += " * @brief Get board initialization status\n";
    footer += " * @return Board initialization status\n";
    footer += " */\n";
    footer += "int cvi_board_init_status(void)\n";
    footer += "{\n";
    footer += "    // Return board initialization status\n";
    footer += "    return 0; // Success\n";
    footer += "}\n";
    
    return footer;
}

QString CodeGenerator::getPinMuxName(const QString& pinName, const QString& function)
{
    // 根据引脚名称和功能生成PINMUX宏名称
    QString basePinName = pinName;
    
    // 处理新的引脚命名方式
    if (basePinName.startsWith("PIN_")) {
        // 旧的PIN_数字格式
        int pinNumber = basePinName.mid(4).toInt();
        if (pinNumber <= 32) {
            basePinName = QString("GPIOA%1").arg(pinNumber - 1);
        } else {
            basePinName = QString("GPIOB%1").arg(pinNumber - 33);
        }
    } else if (basePinName.contains(QRegularExpression("^[A-R]\\d+$"))) {
        // BGA格式：A1, B2, 等
        QChar rowChar = basePinName[0];
        int colNumber = basePinName.mid(1).toInt();
        
        // 将BGA坐标转换为GPIO编号
        // 这里使用简化映射，实际项目中需要根据具体芯片规格书映射
        int rowIndex = rowChar.toLatin1() - 'A';
        if (rowChar >= 'J') rowIndex--; // 跳过I
        
        int gpioNumber = rowIndex * 15 + (colNumber - 1);
        
        if (gpioNumber < 64) {
            basePinName = QString("GPIOA%1").arg(gpioNumber);
        } else {
            basePinName = QString("GPIOB%1").arg(gpioNumber - 64);
        }
    } else if (basePinName.contains(QRegularExpression ("^\\d+$"))) {
        // QFN格式：纯数字
        int pinNumber = basePinName.toInt();
        if (pinNumber <= 32) {
            basePinName = QString("GPIOA%1").arg(pinNumber - 1);
        } else {
            basePinName = QString("GPIOB%1").arg(pinNumber - 33);
        }
    }
    
    // 生成功能宏名称
    QString functionMacro;
    if (function == "I2C") {
        // I2C功能需要区分SDA和SCL
        static int i2cIndex = 0;
        if (i2cIndex % 2 == 0) {
            functionMacro = QString("IIC%1_SDA").arg(i2cIndex / 2);
        } else {
            functionMacro = QString("IIC%1_SCL").arg(i2cIndex / 2);
        }
        i2cIndex++;
    } else if (function == "UART") {
        // UART功能需要区分TX和RX
        static int uartIndex = 0;
        if (uartIndex % 2 == 0) {
            functionMacro = QString("UART%1_TX").arg(uartIndex / 2);
        } else {
            functionMacro = QString("UART%1_RX").arg(uartIndex / 2);
        }
        uartIndex++;
    } else if (function == "SPI") {
        // SPI功能需要区分不同信号线
        static int spiIndex = 0;
        QStringList spiSignals = {"CLK", "MOSI", "MISO", "CS"};
        functionMacro = QString("SPI%1_%2").arg(spiIndex / 4).arg(spiSignals[spiIndex % 4]);
        spiIndex++;
    } else if (function == "ADC") {
        static int adcIndex = 0;
        functionMacro = QString("ADC%1").arg(adcIndex);
        adcIndex++;
    } else if (function == "PWM") {
        static int pwmIndex = 0;
        functionMacro = QString("PWM%1").arg(pwmIndex);
        pwmIndex++;
    } else if (function == "Timer") {
        static int timerIndex = 0;
        functionMacro = QString("TIMER%1").arg(timerIndex);
        timerIndex++;
    } else {
        functionMacro = function.toUpper();
    }
    
    return functionMacro;
}

void CodeGenerator::initializeFunctionMacros()
{
    m_functionMacros["GPIO"] = "GPIO";
    m_functionMacros["ADC"] = "ADC";
    m_functionMacros["I2C"] = "IIC";
    m_functionMacros["UART"] = "UART";
    m_functionMacros["SPI"] = "SPI";
    m_functionMacros["PWM"] = "PWM";
    m_functionMacros["Timer"] = "TIMER";
}
