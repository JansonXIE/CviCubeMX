#include "codegenerator.h"
#include <QRegularExpression>
#include <QFile>
#include <QTextStream>
#include <QDebug>
static bool isGpioMode(const QString &func);
static QString generateEthSequence(const QMap<QString, QString>& pinFunctions);
static QString generateMipiSequence(const QMap<QString, QString>& pinFunctions);
static QString generateAudioSequence(const QMap<QString, QString>& pinFunctions);
CodeGenerator::CodeGenerator()
{
    initializeFunctionMacros();
}

QString CodeGenerator::generateCode(const ChipConfig& config)
{
    // 检查是否存在默认的 cvi_board_init.c 文件
    QString defaultFilePath = "C:\\Users\\situo.su\\CviCubeMX\\boards\\cv184x\\cv1842hp_wevb_0014a_emmc\\u-boot\\cvi_board_init.c";
    QFile defaultFile(defaultFilePath);
    
    if (defaultFile.exists()) {
        // 如果存在默认文件，则更新它
        return updateExistingFile(defaultFilePath, config);
    } else {
        // 如果不存在默认文件，则生成新的代码（保留原有逻辑）
        QString code;
        
        // 生成文件头
        code += generateHeader();
        
        // 生成包含文件
        // code += "\n#include \"cvi_board_init.h\"\n";
        // code += "#include \"pinmux.h\"\n\n";
        
        // 生成引脚复用函数
        code += generatePinmuxFunction(config);
        
        return code;
    }
}

QString CodeGenerator::updateExistingFile(const QString& filePath, const ChipConfig& config)
{
    QFile file(filePath);
    if (!file.open(QIODevice::ReadOnly | QIODevice::Text)) {
        return QString("Error: Cannot open file %1").arg(filePath);
    }

    QTextStream in(&file);
    QString content = in.readAll();
    file.close();

    // 查找现有的生成配置块并删除（包括前后的空行）
    QRegularExpression generatedRegex("\\n*\\s*// Generated PINMUX configurations\\n.*?(?=\\n*\\s*return\\s+0\\s*;)", 
                                     QRegularExpression::DotMatchesEverythingOption);
    content.remove(generatedRegex);
    
    // 清理可能存在的多余换行符（在return之前）
    QRegularExpression multipleNewlines("(\\n\\s*){3,}(\\s*return\\s+0\\s*;)");
    content.replace(multipleNewlines, "\n\n\\2");
    
    // 查找 return 0; 的位置，但不依赖其当前的缩进状态
    QRegularExpression returnRegex("\\n*\\s*return\\s+0\\s*;");
    QRegularExpressionMatch match = returnRegex.match(content);
    
    if (!match.hasMatch()) {
        return "Error: Cannot find 'return 0;' in the existing file";
    }
    
    int returnPosition = match.capturedStart();
    
    // 生成新的 PINMUX 配置
    QString pinmuxConfig = generatePinmuxConfig(config);

    // 也基于相同的 pinFunctions 生成 ETH / MIPI / Audio 的特殊寄存器序列，
    // 因为 updateExistingFile 分支只插入 PINMUX_CONFIG，需要把这些序列追加
    QMap<QString, QString> pinFunctions = config.getAllPinFunctions();
    QString specialSeq;
    specialSeq += generateEthSequence(pinFunctions);
    specialSeq += generateMipiSequence(pinFunctions);
    specialSeq += generateAudioSequence(pinFunctions);
    if (!specialSeq.isEmpty()) {
        // 保证特殊序列与 PINMUX_CONFIG 之间有空行
        if (!pinmuxConfig.endsWith("\n")) pinmuxConfig += "\n";
        // 将生成的行每行前加一个制表符进行对齐（写入到文件中时与其它行一致）
        QStringList lines = specialSeq.split('\n', Qt::SkipEmptyParts);
        for (const QString &ln : lines) {
            pinmuxConfig += "\t" + ln + "\n";
        }
    }

    if (!pinmuxConfig.isEmpty()) {
        // 在 return 0; 之前插入新的配置
        QString newContent = content.left(returnPosition);

        // 确保以换行结尾
        if (!newContent.endsWith("\n")) {
            newContent += "\n";
        }

        // 始终使用制表符缩进，不依赖于当前return语句的缩进状态
        newContent += "\n\t// Generated PINMUX configurations\n";
        newContent += pinmuxConfig;
        newContent += "\n\treturn 0;\n";
        newContent += "}";

        // 写回文件
        if (!file.open(QIODevice::WriteOnly | QIODevice::Text)) {
            return QString("Error: Cannot write to file %1").arg(filePath);
        }

        QTextStream out(&file);
        out << newContent;
        file.close();

        return "File updated successfully";
    } else {
        // 如果没有配置要添加，确保删除任何现有的生成配置，并保持正确的return格式
        QRegularExpression returnFix("\\n*\\s*return\\s+0\\s*;");
        content.replace(returnFix, "\n\treturn 0;");

        if (!file.open(QIODevice::WriteOnly | QIODevice::Text)) {
            return QString("Error: Cannot write to file %1").arg(filePath);
        }

        QTextStream out(&file);
        out << content;
        file.close();

        return "Existing generated configurations removed";
    }
}

QString CodeGenerator::generateHeader()
{
    QString header;
    QDateTime currentTime = QDateTime::currentDateTime();
    
    header += "/**\n";
    header += " * @file cvi_board_init.c\n";
    header += " * @brief Board initialization file generated by CviCubeMX\n";
    header += " * @author CviCubeMX Tool\n";
    header += QString(" * @date %1\n").arg(currentTime.toString("yyyy-MM-dd hh:mm:ss"));
    header += " */\n\n";
    
    return header;
}
// Helper: 判断某个功能字符串是否表示 GPIO 模式（包含或以 GPIO 相关前缀开头）
static bool isGpioMode(const QString &func)
{
    if (func.isEmpty())
        return false;
    // 常见 GPIO 表示形式：直接包含 "GPIO"，或以 "XGPIO"/"PWR_GPIO" 等前缀
    if (func.startsWith("XGPIO", Qt::CaseInsensitive) ||
        func.startsWith("PWR_GPIO", Qt::CaseInsensitive) ||
        func.contains("GPIO", Qt::CaseInsensitive))
        return true;
    return false;
}

// 帮助函数：为 ETH pads 生成特殊寄存器序列（当设置为 GPIO 时）
static QString generateEthSequence(const QMap<QString, QString>& pinFunctions)
{
    QString seq;
    QStringList specialEthPads = {
        "PAD_ETH_RXM___EPHY_TXP",
        "PAD_ETH_RXP___EPHY_TXN",
        "PAD_ETH_TXM___EPHY_RXP",
        "PAD_ETH_TXP___EPHY_RXN"
    };

    bool need = false;
    for (const QString &pad : specialEthPads) {
        if (isGpioMode(pinFunctions.value(pad))) {
            need = true;
            break;
        }
    }

    if (!need)
        return seq;

    seq += "    /* Special sequence: configure EPHY for GPIO on ETH pads */\n";
    seq += "    /* Note: requires mmio_read/mmio_write and udelay helpers */\n";
    seq += "    /* enable apb interface */\n";
    seq += "    mmio_write(0x03009804, mmio_read(0x03009804) | 0x1); // rg_ephy_apb_rw_sel = 1\n";
    seq += "    /* set pll stable cnt = 1 (10us) */\n";
    seq += "    mmio_write(0x03009808, (mmio_read(0x03009808) & ~0x1F) | 0x1);\n";
    seq += "    /* release ephy reset */\n";
    seq += "    mmio_write(0x03009800, mmio_read(0x03009800) | (1 << 2)); // rg_ephy_dig_rst_n = 1\n";
    seq += "    udelay(10); /* wait 10us */\n";
    seq += "    /* select page 5 */\n";
    seq += "    mmio_write(0x0300907C, (mmio_read(0x0300907C) & ~(0x1F << 8)) | (5 << 8));\n";
    seq += "    /* set to gpio from top */\n";
    seq += "    mmio_write(0x03009078, (mmio_read(0x03009078) & ~0xFFF) | 0xF00);\n";
    seq += "    /* enable ephy rxp&rxm input & output */\n";
    seq += "    mmio_write(0x03009074, (mmio_read(0x03009074)| 0x606));\n";
    seq += "    mmio_write(0x03009070, (mmio_read(0x03009070)| 0x606));\n";
    seq += "    /* back to page 0 */\n";
    seq += "    mmio_write(0x0300907C, 0x0);\n";
    seq += "    /* set PHY MDI mode to Force MDIX (bits[1:0] = 01) */\n";
    seq += "    mmio_write(0x0300904C, (mmio_read(0x0300904C) & ~0x3) | 0x1);\n";
    seq += "\n";
    seq += "\t/* PAD_ETH PINMUX GPIO extra config END */\n";
    seq += "\n";
    return seq;
}

// 帮助函数：为 MIPI pads 生成寄存器配置（TXM/TXP/RX -> 指定位写 0/1）
static QString generateMipiSequence(const QMap<QString, QString>& pinFunctions)
{
    QString seq;

    // TXM pads 对应 reg_pd_lptrx bit0..4 @ 0x0A098064 (低4位) 和 reg_pd_txdvr_ldo bit8..12 @ 0x0A098064 (高4位)
    QStringList txm = { "PAD_MIPI_TXM0","PAD_MIPI_TXP0","PAD_MIPI_TXM1", "PAD_MIPI_TXP1","PAD_MIPI_TXM2","PAD_MIPI_TXP2", "PAD_MIPI_TXM3", "PAD_MIPI_TXP3", "PAD_MIPI_TXM4" ,"PAD_MIPI_TXP4"};
    bool need = false;
    unsigned int vallow = 0;
    unsigned int valtop = 0;
    unsigned int masklow =0;
    unsigned int masktop =0;
    //按照这个循环，当前没办法保留原有的的配置，只能bit全部重写，当前选gpio的就写1，非gpio的就写0
    for (int i = 0; i < txm.size(); ++i) {
        const QString func = pinFunctions.value(txm[i]);
        if (isGpioMode(func)) {
            vallow |= (1u << i/2);
            valtop |= (1u << (i/2 + 8));
            need = true;
        } else {
            masklow |= (1u << i/2);
            masktop |= (1u << (i/2 + 8));
        }
    }
    // MIPI RX: PAD_MIPIRX0N/0P/1N/1P/3N/3P -> bits16..21 @ 0x0A0A6000
    QStringList rx = { "PAD_MIPIRX0N", "PAD_MIPIRX0P", "PAD_MIPIRX1N", "PAD_MIPIRX1P",  "PAD_MIPIRX2N", "PAD_MIPIRX2P","PAD_MIPIRX3N", "PAD_MIPIRX3P", "PAD_MIPIRX4N", "PAD_MIPIRX4P", "PAD_MIPIRX5N", "PAD_MIPIRX5P"};
    unsigned int maskRX = 0;
    unsigned int valRX = 0;
    //按照这个循环，当前没办法保留原有的的配置，只能bit全部重写，当前选gpio的就写1，非gpio的就写0
    for (int i = 0; i < rx.size(); ++i) {
        const QString &pin = rx[i];
        const QString func = pinFunctions.value(pin);
        if (isGpioMode(func)) {
            maskRX |= (1u << (16 + i/2));
            valRX |= (1u << (16 + i/2));
            need = true;
        } else {
            maskRX |= (1u << (16 + i/2));
        }
    }
    if(!need)
        return seq;
    if(vallow){
        seq += "    /* MIPI TX: set reg_pd_lptrx/reg_pd_txdvr_ldo according to GPIO/MIPI selection */\n";
    
        seq += QString("    mmio_write(0x0A098064, (mmio_read(0x0A098064) & ~0x%1) | 0x%2);\n")
            .arg(QString::number(masklow, 16).toUpper())
            .arg(QString::number(vallow, 16).toUpper());
        
    }
    
   if(valtop){
    seq += QString("    mmio_write(0x0A098064, (mmio_read(0x0A098064) & ~0x%1) | 0x%2);\n")
            .arg(QString::number(masktop, 16).toUpper())
            .arg(QString::number(valtop, 16).toUpper());
    
    seq += "\n";
    }
    if(valRX){
        seq += "    /* MIPI RX: reg_mipirx_pd_rxlp set for GPIO/MIPI */\n";
        seq += QString("    mmio_write(0x0A0A6000, (mmio_read(0x0A0A6000) & ~0x%1) | 0x%2);\n")
                .arg(QString::number(maskRX, 16).toUpper())
                .arg(QString::number(valRX, 16).toUpper());
        seq += "\n";
    }
    
    seq += "\t/* PAD_MIPI PINMUX extra config set END */\n";
    seq += "\n";
    return seq;
}

// 帮助函数：为 Audio pads 生成寄存器配置（Analog(00) vs GPIO(non-00)）
static QString generateAudioSequence(const QMap<QString, QString>& pinFunctions)
{
    QString seq;
    bool need = false;
    // PAD_AUD_AINL_MIC,PAD_AUD_AINR -> 0x03002204[23:22],0x0300212C[3:2]
    QString p1 = "PAD_AUD_AINL_MIC";
    QString p2 = "PAD_AUD_AINR";
    QString pinValue1=pinFunctions.value(p1);
    QString pinValue2=pinFunctions.value(p2);
    if (pinFunctions.contains(p1)||pinFunctions.contains(p2)) {
        unsigned int mask = (0x3u << 22);
        unsigned int val = (isGpioMode(pinValue1)||isGpioMode(pinValue2)) ? (0x1u << 22) : 0;
        seq += QString("    mmio_write(0x03002204, (mmio_read(0x03002204) & ~0x%1) | 0x%2);\n")
                .arg(QString::number(mask, 16).toUpper())
                .arg(QString::number(val, 16).toUpper());
        mask = (0x3u << 2);
        val = (isGpioMode(pinValue1)||isGpioMode(pinValue2)) ? (0x1u << 2) : 0;
        seq += QString("    mmio_write(0x0300212C, (mmio_read(0x0300212C) & ~0x%1) | 0x%2);\n")
                .arg(QString::number(mask, 16).toUpper())
                .arg(QString::number(val, 16).toUpper());
        need = true;
    }


    // PAD_AUD_AOUTL -> 0x03002204[25:24],PAD_AUD_AOUTR -> 0x03002100[1:0]
    QString p3 = "PAD_AUD_AOUTL";
    QString p4 = "PAD_AUD_AOUTR";
    QString pinValue3=pinFunctions.value(p3);
    QString pinValue4=pinFunctions.value(p4);
    if (pinFunctions.contains(p3)||pinFunctions.contains(p4)) {
        unsigned int mask = (0x3u << 24);
        unsigned int val = (isGpioMode(pinValue3)||isGpioMode(pinValue4))? (0x1u << 24) : 0;
        seq += QString("    mmio_write(0x03002204, (mmio_read(0x03002204) & ~0x%1) | 0x%2);\n")
                .arg(QString::number(mask, 16).toUpper())
                .arg(QString::number(val, 16).toUpper());
        mask = 0x3u;
        val =  (isGpioMode(pinValue3)||isGpioMode(pinValue4)) ? 0x1u : 0;
        seq += QString("    mmio_write(0x03002100, (mmio_read(0x03002100) & ~0x%1) | 0x%2);\n")
                .arg(QString::number(mask, 16).toUpper())
                .arg(QString::number(val, 16).toUpper());
        need = true;
    }

    if (!seq.isEmpty())
        seq = "    /* Audio pad mode adjustments (analog=00, gpio!=00) */\n" + seq + "\n";
    if (!need)
        return seq;
    seq += "\t/*PAD_AUD PINMUX extra config END*/\n";
    seq += "\n";
    return seq;
}
QString CodeGenerator::generatePinmuxFunction(const ChipConfig& config)
{
    QString function;
    
    function += "/**\n";
    function += " * @brief Initialize board pin multiplexing\n";
    function += QString(" * @note Generated for chip: %1\n").arg(config.getChipType());
    function += " */\n";
    function += "int cvi_board_init(void)\n";
    function += "{\n";
    
    // 添加芯片类型注释
    function += QString("    // Pin configuration for %1\n").arg(config.getChipType());
    function += "    // Package type: ";
    
    QString chipType = config.getChipType();
    bool isQFN = (chipType.endsWith('c') || chipType == "cv1842cp");
    bool isBGA = (chipType.endsWith('h') || chipType == "cv1842hp");
    
    if (isQFN) {
        function += "QFN (Quad Flat No-leads)\n";
    } else if (isBGA) {
        function += "BGA (Ball Grid Array)\n";
    } else {
        function += "Unknown\n";
    }
    function += "\n";
    
    // 生成引脚复用配置
    QMap<QString, QString> pinFunctions = config.getAllPinFunctions();
    
    // 按功能分组
    QMap<QString, QStringList> functionGroups;
    for (auto it = pinFunctions.begin(); it != pinFunctions.end(); ++it) {
        QString pinName = it.key();
        QString funcName = it.value();
        if (funcName != "GPIO") { // GPIO不需要特殊配置
            functionGroups[funcName].append(pinName);
        }
    }

    // 精简调试：只打印计数和前若干条示例，避免控制台刷屏
    qDebug() << "CodeGenerator::generatePinmuxFunction - pinFunctions size =" << pinFunctions.size();
    if (!pinFunctions.isEmpty()) {
        int shown = 0;
        for (auto it = pinFunctions.constBegin(); it != pinFunctions.constEnd() && shown < 6; ++it, ++shown) {
            qDebug() << "  sample pin:" << it.key() << "->" << it.value();
        }
        if (pinFunctions.size() > shown)
            qDebug() << "  ...(+" << (pinFunctions.size() - shown) << " more pin entries)";
    }
    qDebug() << "CodeGenerator::generatePinmuxFunction - functionGroups size =" << functionGroups.size();
    if (!functionGroups.isEmpty()) {
        int shown = 0;
        for (auto it = functionGroups.constBegin(); it != functionGroups.constEnd() && shown < 6; ++it, ++shown) {
            qDebug() << "  sample func:" << it.key() << "->" << it.value().join(", ");
        }
        if (functionGroups.size() > shown)
            qDebug() << "  ...(+" << (functionGroups.size() - shown) << " more function groups)";
    }

    // 将映射写入生成的 c 文件作为注释，便于在 cvi_board_init.c 中核对
    function += "    /* Debug: pinFunctions mapping (key -> value)\n";
    if (pinFunctions.isEmpty()) {
        function += "     * <empty>\n";
    } else {
        for (auto it = pinFunctions.constBegin(); it != pinFunctions.constEnd(); ++it) {
            function += QString("     * %1 -> %2\n").arg(it.key(), it.value());
        }
    }
    function += "     */\n\n";

    function += "    /* Debug: functionGroups (function -> pins)\n";
    if (functionGroups.isEmpty()) {
        function += "     * <empty>\n";
    } else {
        for (auto it = functionGroups.constBegin(); it != functionGroups.constEnd(); ++it) {
            function += QString("     * %1 -> %2\n").arg(it.key(), it.value().join(", "));
        }
    }
    function += "     */\n\n";
    
    // 生成每个功能组的配置
    for (auto it = functionGroups.begin(); it != functionGroups.end(); ++it) {
        QString funcName = it.key();
        QStringList pins = it.value();
        
        function += QString("    // %1 pins configuration\n").arg(funcName);
        
        for (const QString& pinName : pins) {
            QString pinmuxMacro = getPinMuxName(pinName, funcName);
            function += QString("    PINMUX_CONFIG(%1, %2);\n").arg(pinName, pinmuxMacro);
        }
        function += "\n";
    }
    
    // 调用封装的特殊序列生成函数（ETH / MIPI / Audio）
    function += generateEthSequence(pinFunctions);
    function += generateMipiSequence(pinFunctions);
    function += generateAudioSequence(pinFunctions);
    
    // 如果没有配置任何引脚，添加默认注释
    if (functionGroups.isEmpty()) {
        function += "    // No special pin functions configured\n";
        function += "    // All pins are set to GPIO by default\n";
    }
    
    function += "}\n";
    
    return function;
}

QString CodeGenerator::generatePinmuxConfig(const ChipConfig& config)
{
    QString configCode;
    
    // 生成引脚复用配置
    QMap<QString, QString> pinFunctions = config.getAllPinFunctions();
    
    // 按功能分组
    QMap<QString, QStringList> functionGroups;
    for (auto it = pinFunctions.begin(); it != pinFunctions.end(); ++it) {
        QString pinName = it.key();
        QString funcName = it.value();
        if (funcName != "GPIO") { // GPIO不需要特殊配置
            functionGroups[funcName].append(pinName);
        }
    }
    
    // 生成每个功能组的配置
    bool firstGroup = true;
    for (auto it = functionGroups.begin(); it != functionGroups.end(); ++it) {
        QString funcName = it.key();
        QStringList pins = it.value();
        
        if (!firstGroup) {
            configCode += "\n";
        }
        firstGroup = false;
        
        // 使用制表符缩进，与文件中其他行保持一致
        configCode += QString("\t// %1 pins configuration\n").arg(funcName);
        
        for (const QString& pinName : pins) {
            QString pinmuxMacro = getPinMuxName(pinName, funcName);
            configCode += QString("\tPINMUX_CONFIG(%1, %2);\n").arg(pinName, pinmuxMacro);
        }
    }
    
    return configCode;
}

QString CodeGenerator::getPinMuxName(const QString& pinName, const QString& function)
{
    // 使用新的引脚功能系统获取宏名称
    QString macroName = m_pinFunction.getFunctionMacroName(pinName, function);
    
    // 如果没有找到特定的宏名称，使用通用的处理方式
    if (macroName == function.toUpper()) {
        // 根据引脚名称和功能生成PINMUX宏名称
        QString basePinName = pinName;
        
        // 处理新的引脚命名方式
        if (basePinName.startsWith("PIN_")) {
            // 旧的PIN_数字格式
            int pinNumber = basePinName.mid(4).toInt();
            if (pinNumber <= 32) {
                basePinName = QString("GPIOA%1").arg(pinNumber - 1);
            } else {
                basePinName = QString("GPIOB%1").arg(pinNumber - 33);
            }
        } else if (basePinName.contains(QRegularExpression("^[A-R]\\d+$"))) {
            // BGA格式：A1, B2, 等
            QChar rowChar = basePinName[0];
            int colNumber = basePinName.mid(1).toInt();
            
            // 将BGA坐标转换为GPIO编号
            // 这里使用简化映射，实际项目中需要根据具体芯片规格书映射
            int rowIndex = rowChar.toLatin1() - 'A';
            if (rowChar >= 'J') rowIndex--; // 跳过I
            
            int gpioNumber = rowIndex * 15 + (colNumber - 1);
            
            if (gpioNumber < 64) {
                basePinName = QString("GPIOA%1").arg(gpioNumber);
            } else {
                basePinName = QString("GPIOB%1").arg(gpioNumber - 64);
            }
        } else if (basePinName.contains(QRegularExpression ("^\\d+$"))) {
            // QFN格式：纯数字
            int pinNumber = basePinName.toInt();
            if (pinNumber <= 32) {
                basePinName = QString("GPIOA%1").arg(pinNumber - 1);
            } else {
                basePinName = QString("GPIOB%1").arg(pinNumber - 33);
            }
        }
        
        // 如果是特定功能，直接返回功能宏名称
        if (function.contains("CAM_") || function.contains("AUX") || 
            function.contains("DBG_") || function.contains("XGPIO") ||
            function.contains("PAD_") || function.contains("VI") ||
            function.contains("VO") || function.contains("SD") ||
            function.contains("MIPI") || function.contains("PWM_") ||
            function.contains("IIC")) {
            return function;
        }
        
        // 生成通用功能宏名称
        QString functionMacro;
        if (function == "I2C") {
            // I2C功能需要区分SDA和SCL
            static int i2cIndex = 0;
            if (i2cIndex % 2 == 0) {
                functionMacro = QString("IIC%1_SDA").arg(i2cIndex / 2);
            } else {
                functionMacro = QString("IIC%1_SCL").arg(i2cIndex / 2);
            }
            i2cIndex++;
        } else if (function == "UART") {
            // UART功能需要区分TX和RX
            static int uartIndex = 0;
            if (uartIndex % 2 == 0) {
                functionMacro = QString("UART%1_TX").arg(uartIndex / 2);
            } else {
                functionMacro = QString("UART%1_RX").arg(uartIndex / 2);
            }
            uartIndex++;
        } else if (function == "SPI") {
            // SPI功能需要区分不同信号线
            static int spiIndex = 0;
            QStringList spiSignals = {"CLK", "MOSI", "MISO", "CS"};
            functionMacro = QString("SPI%1_%2").arg(spiIndex / 4).arg(spiSignals[spiIndex % 4]);
            spiIndex++;
        } else if (function == "ADC") {
            static int adcIndex = 0;
            functionMacro = QString("ADC%1").arg(adcIndex);
            adcIndex++;
        } else if (function == "PWM") {
            static int pwmIndex = 0;
            functionMacro = QString("PWM%1").arg(pwmIndex);
            pwmIndex++;
        } else if (function == "Timer") {
            static int timerIndex = 0;
            functionMacro = QString("TIMER%1").arg(timerIndex);
            timerIndex++;
        } else {
            functionMacro = function.toUpper();
        }
        
        return functionMacro;
    }
    
    return macroName;
}

void CodeGenerator::initializeFunctionMacros()
{
    m_functionMacros["GPIO"] = "GPIO";
    m_functionMacros["ADC"] = "ADC";
    m_functionMacros["I2C"] = "IIC";
    m_functionMacros["UART"] = "UART";
    m_functionMacros["SPI"] = "SPI";
    m_functionMacros["PWM"] = "PWM";
    m_functionMacros["Timer"] = "TIMER";
}
